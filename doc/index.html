<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Stapes.js - a (really) tiny Javascript MVC microframework</title>
    <style>
        body {
            font-family: Helvetica, Arial, sans-serif;
            color: #333;
            padding: 20px;
            background: #eee;
        }

        p {
            font-size: 16px;
            line-height: 24px;
        }

        body > h1 {
            font-family: Georgia;
            font-style: italic;
            color: #150683;
            font-size: 48px;
            letter-spacing: 1px;
        }

        pre {
            border-left: 5px solid #999;
            background: white;
        }

        h3 {
            font-size: 24px;
            color: #150683;
            margin-top: 40px;
        }

        article {
            margin: 20px 0;
        }

        article h1 {
            font-size: 18px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            color: #666;
        }

        article h2 {
            font-family: monospace;
            font-size: 14px;
            background: #eee;
            padding: 10px;
        }

        p code {
            background: white;
            border: 1px solid #ccc;
            padding: 1px;
        }
    </style>
</head>
<body>
    <h1>Stapes.js</h1>

    <p>A (really) tiny Javascript MVC microframework.</p>

    <p>Provided 'Stapes' is a global in your scope, write your Stapes modules
    like this</p>

    <pre><code>
    var Module = Stapes.create();

    Module.extend({
        "init" : function() {
            this.emit('ready');
        }
    });
    </code></pre>

    <p>Then, use it like this.</p>

    <pre><code>
    var module = Module.create();

    module.on('ready', function() {
        console.log('woot! ready!');
    });

    module.init(); // 'woot! ready!'
    </code></pre>

    <p><code>create()</code> returns <code>this</code>, so yo could write the
    previous example like this as well.</p>

    <pre><code>
    var Module = Stapes.create().extend({
        "init" : function() {
            this.emit('ready');
        }
    });
    </code></pre>

    <p>If you want to use private variables and functions, use Stapes like this</p>

    <pre><code>
    (function() {
        var private;

        function showPrivate() {
            console.log("You shouldn't be seeing this", private);
        }

        window.Module = Stapes.create().extend({
            "show" : function(var) {
                private = var;
                showPrivate();
            }
        });
    })();
    </code></pre>

    <h3>Using it together with RequireJS</h3>

    <p>To avoid lots of global variables you can use a dependency loader like
    <a href="http://www.requirejs.org">Require.JS</a>. This also makes the
    previous example easier to read.

    <pre><code>
    // 'module.js'
    require(["path/to/Stapes"], function(Stapes) {
        var private;

        function showPrivate() {
            console.log("This is private: " + private);s
        }

        return Stapes.create().extend({
            "show" : function(var) {
                private = var;
                showPrivate();
            }
        });
    });

    // somewhere else
    require(['module'], function(Module) {
        var module = Module.create();

        console.log( module.show("Elvis") ); // 'This is private: Elvis',
    });
    </code></pre>

    <h3>General methods</h3>
    <article>
        <h1>create</h1>

        <h2>Stapes.create()</h2>
        <h2>module.create()</h2>

        <p>Create a new instance of a Stapes object.</p>

        <p>Always returns <code>this</code>, so you can easily chain
        <code>create</code> with <code>extend</code></p>
    </article>

    <article>
        <h1>extend</h1>

        <h2>module.extend([context, ]object)</h2>

        <p>Extend your module  by giving an
        object. Keys with the same value will be overwritten. <code>this</code>
        will be set to the objects context. When setting no <code>context</code>
        the properties will be inserted in the current object. However, if you want
        to insert properties 'deeper' into the object, you can specificy that
        as the first parameter</p>

        <pre><code>
        module.extend({
            "names" : {
                "woman" : ['claire', 'alice']
            },

            "sayName" : function(i) {
                console.log( "Hello " + this.names.woman[i] + "!" );
            }
        });

        module.extend(module.names, {
            "man" : ['clark', 'elvis']
        });

        console.log(module.names);
        // Gives:
        // {
        //   "woman" : ['claire', 'alice'],
        //   "man" : ['clark', 'elvis']
        // }
        </code></pre>
    </article>

    <h3>Events</h3>
    <article>
        <h1>on</h1>

        <h2>module.on(eventName, handler, context)</h2>
        <h2>module.on(object, context);</h2>

        <p>Event listener. Events are only thrown on this object and won't
        be thrown in other Stapes objects. <code>handler</code> will be called
        with two arguments: <code>data</code>, which may contain any data, and an
        <code>eventObject</code> that contains some useful information about the
        event, such as the scope, target and event name</p>

        <pre><code>
        module.on('ready', function() {
            console.log('your module is ready!');
        });

        module.on({
            "talk" : function() {
                console.log('your module is talking!');
            },

            "walk" : function() {
                console.log('your module is walking!');
            }
        })
        </code></pre>
    </article>

    <article>
        <h1>emit</h1>

        <h2>module.emit(eventName[, data])</h2>

        <p>Trigger an event. <code>eventName</code> can be a space seperated
        string if you want to trigger more events. <code>data</code> can be any
        Javascript variable you want, and will be passed to any event listeners</p>

        <pre><code>
        module.extend({
            "sleep" : function() {
                this.emit('sleeping', 'very deep');
            }
        });
        </code></pre>
    </article>

    <h3>Data methods</h3>
    <article>
        <h1>remove</h1>

        <h2>module.remove( key );</h2>
        <h2>module.remove( function );</h2>

        <p>Deletes an attribute. Triggers <code>delete</code> and
        <code>change</code> events.</p>

        <p>You can either use a <code>key</code> as an argument or a
        <code>function</code></p>

        <pre><code>
        module.remove(function(item) {
            return item.done === true;
        });
        </code></pre>
    </article>

    <article>
        <h1>get</h1>

        <h2>module.get( key );</h2>

        <p>Gets an attribute. If the item is not available will return
        <code>null</code></p>
    </article>

    <article>
        <h1>getAll</h1>

        <h2>module.getAll();</h2>

        <p>Returns all attributes as an object.</p>
    </article>

    <article>
        <h1>getAllAsArray</h1>

        <h2>module.getAllAsArray();</h2>

        <p>Returns all attributes as an array, so you can easily iterate.
        Note that the original key of the attribute is always available as a
        'id' key in the the value, provided your value is an object.</p>
    </article>

    <article>
        <h1>set</h1>

        <h2>module.set(key, value);</h2>
        <h2>module.set(object);</h2>

        <p>Sets an attribute. Use <code>push</code> if you want to 'push' a value
        with a random uuid, for collections</p>

        <p>To set multiple attributes in one go, use an object as the first argument.</p>

        <p>Every attribute will trigger a <code>change</code> event. A key
        that doesn't exist will trigger a <code>create</code> event, a key
        that does exist will trigger an <code>update</code> event.</p>

        <p>All events will have the key of the attribute as their event value.</p>

        <pre><code>
            module.on({
                "change" : function(key) {
                    console.log('Something happened with ' + key);
                },

                "create" : function(key) {
                    console.log("New attribute " + key + " added!");
                },

                "update" : function(key) {
                    console.log("Attribute " + key + " was updated!");
                }
            });

            module.set('name', 'Elvis'); // will trigger 'change' and 'create' events
            module.set('name', 'Johnny'); // will trigger 'change' and 'update' events
            module.set({
                "name" : "Elvis",
                "instrument" : "guitar"
            });
        </code></pre>
    </article>

    <article>
        <h1>push</h1>

        <h2>module.push( value );</h2>
        <h2>module.push( array );</h2>

        <p>Sets a value, automatically generates an unique id</p>

        <p>You can also push an array of values.</p>

        <p>Behaves exactly the same as <code>set</code>, but doesn't need a key.</p>
    </article>

    <article>
        <h1>filter</h1>

        <h2>module.filter( function );</h2>

        <p>Gets an attribute using a custom function.</p>

        <pre><code>
            module.set('singer', {
                'name' : 'Elvis',
                'instrument' : 'Guitar'
            });

            var singer = module.filter(function(item) {
                return item.name === "Elvis";
            });
        </code></pre>
    </article>

    <article>
        <h1>has</h1>

        <h2>module.has( key );</h2>

        <p>Checks if a key is available and returns true or false.</p>
    </article>
</body>
</html>